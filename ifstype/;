import bisect
from collections import defaultdict
from .rational import Rational

def check_eq(fn):
    def wrapper(self, other):
        assert self.ring is other.ring, "Symbolic elements originating from distinct SymbolicRing instances"
        return fn(self, other)
    return wrapper

class _PowerIdx(tuple):
    def __new__(cls, idx):
        self = super().__new__(cls,idx)
        return self

    def __add__(self, other):
        return _PowerIdx(s+o for s,o in zip(self,other))

class SymbolicRing:
    """Governing ring of symbolic elements on a fixed set of symbols."""
    def __init__(self, symbols):
        self.symb_dct = {symbol:idx for idx,symbol in enumerate(symbols)}

    def term(self, symbs,coef=1):
        new_dct = {_PowerIdx(1 if p in symbs else 0 for p in self.symb_dct.keys()):coef}
        return SymbolicElement(new_dct, self)

    def default_getter(self):
        return 0

    def add(self, se1, se2):
        "add two symbolic elements together"
        new_dct = defaultdict(self.default_getter,se1.val_dct.copy())
        for k,v in se2.val_dct.items():
            new_dct[k] += v
        return SymbolicElement(new_dct,self)

    def sub(self, se1, se2):
        new_dct = se1.val_dct.copy()
        for k,v in se2.val_dct.items():
            new_dct[k] -= v
        return SymbolicElement(new_dct,self)

    def mul(self, se1, se2):
        new_dct = defaultdict(self.default_getter)
        for (id1,v1),(id2,v2) in itertools.product(se1.val_dct.items(), se2.val_dct.items()):
            new_dct[id1+id2] += v1*v2

    def sig_to_str(self, sig):
        reverse = {v:idx for idx,v in self.symb_dct.items()}
        def check_val(v):
            if v == 1:
                return ""
            else:
                return f"^{v}"

        return "*".join(f"{reverse[idx]}{check_val(v)}" for idx,v in enumerate(sig) if v != 0)

class SymbolicElement:
    def __init__(self, val_dct, ring):
        self.ring = ring
        self.val_dct = val_dct
    
    @check_eq
    def __add__(self, other):
        return self.ring.add(self,other)

    @check_eq
    def __mul__(self, other):
        return self.ring.mul(self,other)

    @check_eq
    def __sub__(self, other):
        return self.ring.sub(self,other)

    def __str__(self):
        terms = "".join((" + " if val >= 0 else " - ") + f"{abs(val)}*{self.ring.sig_to_str(sig)}" for sig,val in self.val_dct.items())
        if terms[1] == "+":
            return terms[3:]
        else:
            return terms[1:]
